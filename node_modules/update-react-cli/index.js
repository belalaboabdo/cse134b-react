'use strict';

const fs = require('fs');
const path = require('path');
const packageJson = require('package-json');

const reactBasePkg = [
	'react',
	'react-dom'
];
const reactAddonPkg = [
	'react-addons-transition-group',
	'react-addons-css-transition-group',
	'react-addons-linked-state-mixin',
	'react-addons-clone-with-props',
	'react-addons-create-fragment',
	'react-addons-update',
	'react-addons-pure-render-mixin',
	'react-addons-shallow-compare',
	'react-addons-test-utils',
	'react-addons-perf'
];

const reactModules = [
	...reactBasePkg,
	...reactAddonPkg
];

function getCurrentPkgInfo(pkgJsonPath) {
	const jsonStr = fs.readFileSync(pkgJsonPath, 'utf-8');
	if (!jsonStr) {
		throw new Error('Current path dont\' have package.json file ');
	}
	let pkgJsonObj = {};
	try {
		pkgJsonObj = JSON.parse(jsonStr);
	} catch (err) {
		throw err;
	}
	return pkgJsonObj;
}

function getReactVersionFromPkg(dependencies = {}, modules = []) {
	return modules.reduce((dependenceModules, name) => {
		if (dependencies[name]) {
			dependenceModules.push([name, dependencies[name]]);
		}
		return dependenceModules;
	}, []);
}

function isNotEmptyObj(obj) {
	return Boolean(obj) && Boolean(Object.keys(obj).length);
}

function checkAllVersion(version, moduels = [], mark) {
	const needUpdateModules = [];
	moduels.forEach(moduleinfo => {
		const [_name, _version] = moduleinfo;
		if (!_version.includes(version)) {
			needUpdateModules.push([mark, _name, _version]);
		}
	});
	return needUpdateModules;
}

function savePkgInfo(path, pkgInfoString = '') {
	if (pkgInfoString === '') {
		throw new Error('No info need to write...');
	}
	return fs.writeFileSync(path, pkgInfoString);
}

module.exports = input => {
	if (typeof input !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof input}`);
	}

	const pkgJsonPath = path.join(process.cwd(), './package.json');
	const pkgInfo = getCurrentPkgInfo(pkgJsonPath);
	const {dependencies, devDependencies} = pkgInfo;

	let depModules = [];
	let	devDepModules = [];
	if (isNotEmptyObj(dependencies)) {
		depModules = getReactVersionFromPkg(dependencies, reactModules);
	}
	if (isNotEmptyObj(devDependencies)) {
		devDepModules = getReactVersionFromPkg(devDependencies, reactModules);
	}
	if (!depModules.length && !devDepModules.length) {
		return new Error('Sorry! Your package not dependence react...');
	}

	return packageJson('react', 'latest').then(pkg => {
		const {version} = pkg;

		const needUpdateDep = checkAllVersion(version, depModules, 'dependencies');
		const needUpdateDevDep = checkAllVersion(version, devDepModules, 'devDependencies');

		if (!needUpdateDep.length && !needUpdateDevDep.legnth) {
			Promise.resolve('All react dependence is lastest, No update available.');
		}

		if (needUpdateDep.length) {
			needUpdateDep.forEach(([__, _name]) => {
				console.log(__, _name);
				pkgInfo.dependencies[_name] = version;
			});
		}

		if (needUpdateDevDep.length) {
			needUpdateDevDep.forEach(([__, _name]) => {
				console.log(__, _name);
				pkgInfo.devDependencies[_name] = version;
			});
		}

		savePkgInfo(pkgJsonPath, JSON.stringify(pkgInfo, null, 2));
		return Promise.resolve('Save Sucess');
	});
};
